<HTML>
<HEAD><TITLE>Harmony Migration Services</TITLE></HEAD>

<BODY BGCOLOR="FFFFFF">

<CENTER><H2>Harmony Migration Services</H2></CENTER>

<P><HR><P>

<H3>Motivation</H3>

<P>

On both the harmony server itself (when extending or upgrading) as
well as on a per-client basis (moving or updating client-specific
configurations) harmony needs to support the migration of data.

<P>

Good support for migrations will allow developers and clients to keep
customer and client data compatible with new features and new designs,
helping everyone get more value out of the server.

<P><HR><P>

<H3>Requirements</H3>

A migration service has certain needs it must meet to be considered
complete. This is the current set of requirements the harmony
migration services is designed to meet:

<P>

<UL>
 <LI>migrations sometimes must be run before any server logic executes</LI>
 <LI>some migrations must run before other migrations</LI>
 <LI>environments may have an unknown data configuration, so it must be
     possible to see which migrations have been run to completion</LI>
 <LI>it must be possible to tell the server that a migration has, in fact, run to completion</LI>
</UL>

<P>

If these requirements are met, it should be easily possible for a
developer to write a migration, either on the client side, or on the
harmony side, that plugs into the migration services and runs only on
the environments it needs to, in the correct order, and without
interference from other logic executing if need be.

<P><HR><P>

<H3>Design</H3>

<P>

The design of the migration services is divided roughly into database
storage, object model and XML representation, a BE service, an FE and BE contoller,
and the migrations themselves.

<P>

<H4>Database Storage</H4>

<P>

The migration services are supported by a database table called
"migration":

<P>

<PRE>
SQL> desc migration;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 ID                                        NOT NULL NUMBER
 NAME                                               VARCHAR2(200)
 COMPLETED                                          VARCHAR2(1)
</PRE>

<P>

<H4>Object Model / XML</H4>

<P>

The object model should reflect the database exactly, with a Migration
model object that contains an id (probably private), a name and the
completed attributes. (<FONT COLOR="red">currently it only has a name</FONT>)

<P>

The XML representation should look like this:

<P>

<PRE>
&lt;migration&gt;
    &lt;name&gt;TestMigration&lt;/name&gt;
    &lt;completed&gt;Y&lt;/completed&gt;
&lt;/migration&gt;
</PRE>

<P>

There should be a simple storage interface layer that allows for two
API calls: one to store a migration, and one to get a migration. It
shouldn't be necessary for a user of the API to know whether the
migration has been stored or not - i.e. the create or update choice
should be hidden by the storage interface. If a request is made for a
migration that has not been stored, a migration object should be
constructed with the same name as the name requested, and a completed
value of 'N'.

<P>

<FONT COLOR="red">This interface needs cleaning, and then it needs to
be exposed to clients as a Dispatcher-available XML interface to store
and fetch migration objects.</FONT>

<P>

<H4>BE Service</H4>

The Harmony Server should expose two API calls two the Java API and
XML API layers, one to store a migration
(<code>Migration.store(Migration migration)</code>), and one to get a
migration (<code>Migration.get(Migration migration)</code>). At the
XML layer, the target should be the migration tag, and the actions
should be "store" and "get". Calling "get" on a migration that has
never run should return a migration object with the same name, and a
completed value of 'N'.

<P>

<H4>FE and BE controller</H4>

<P>

The controllers for migrations should maintain an in-order list of migrations to
run, and then iterate through the list, checking each migration to see
if it has been completed. If it hasn't been completed it, the logic
associated with the migration should be executed, then the controller
should store the migration as having been completed.

<P>

In the harmony server controller, there are two lists, one for
blocking migrations that must run without interference with business
logic, and one list for migrations that can run any time. The
migration logic in the harmony server migrations actually lives in the
migration model object, and is executed as Java code if the migration
needs to run. <FONT COLOR="green">This is already implemented, and its
okay for the service and controller to live in the same object</FONT>

<P>

On the front-end, the list should be an associative array of
migration-name / migration mappings. The front-end
will iterate, in order, through the array to check the status and
execute the migration and store the migration as completed if
necessary. Its anticipated that the front-end controller will be
available at a standalone URL, and will be called at the end of builds
to execute any necessary front-end migrations

<P><HR><P>

<H4>The Migrations</H4>

<P>

The only iron-clad rule for migrations is this: <B>Migrations must be
re-runnable</B>. Running a migration twice, thrice, or <I>n</I> times
should cause no errors. Interrupting a migration, and re-starting it
multiple times should cause no errors. Its okay if there are internal errors (a
create doesn't work the second time, etc) as long as the migration expects and
handles them appropriately.

<P>

On the harmony server side, the migrations are generally dealing with
updating large chunks of data to newer storage formats. Therefore the
migrations are generally in a mix of Java and SQL.

<P>

On the client / front-end side, its probably best to implement the actual
migration logic as an XML file containing a single harmony-command-list,
though for very complex migrations, client logic may be necessary.

<P><HR><P>

<H3>Status - what to do...</H3>

<P>

I think at this point the harmony server-side migrations are working
excellently. In order to expose the storage of migration status to the
front-end so that front-end migrations can take place, the model needs
to be extended somewhat, and it needs to implement
Harmonized/toXml(). The Migration service itself needs to be extended
to expose the store/get API calls with the semantics described above,
and it needs to be added to dispatch.xml so clients can use it.

<P>

At that point, its up to the front-end to implement a controller and
framework to use the API on the client side, then start using it...

</BODY>
</HTML>
